diff --git a/meson.build b/meson.build
index 3e6db1e..859a78e 100644
--- a/meson.build
+++ b/meson.build
@@ -367,6 +367,7 @@ plugins_options_reqs = {
   'wavecom': {'available': true, 'shared': []},
   'x22x': {'available': true, 'shared': []},
   'zte': {'available': true, 'shared': ['icera']},
+  'fm350gl': {'available': true, 'shared': []},
 }
 
 plugins_shared = {}
diff --git a/meson_options.txt b/meson_options.txt
index 799d6c3..beca80a 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -79,3 +79,4 @@ option('gtk_doc', type: 'boolean', value: false, description: 'use gtk-doc to bu
 option('bash_completion', type: 'boolean', value: true, description: 'install bash completion files')
 
 option('fuzzer', type: 'boolean', value: false, description: 'build fuzzer tests')
+option('plugin_fm350gl', type: 'feature', value: 'auto', description: 'enable fm350gl plugin support')
diff --git a/src/plugins/fm350gl/77-mm-fm350gl.rules b/src/plugins/fm350gl/77-mm-fm350gl.rules
new file mode 100644
index 0000000..5fb76e0
--- /dev/null
+++ b/src/plugins/fm350gl/77-mm-fm350gl.rules
@@ -0,0 +1,41 @@
+# /lib/udev/rules.d/77-mm-fm350gl.rules 
+
+
+   # do not edit this file, it will be overwritten on update
+
+   ACTION!="add|change|move|bind", GOTO="mm_fm350gl_port_types_end"
+   SUBSYSTEMS=="usb", ATTRS{idVendor}=="0e8d", GOTO="mm_fm350gl_port_types_vendorcheck"
+   GOTO="mm_fm350gl_port_types_end"
+
+   # FM350GL devices ---------------------------
+
+  LABEL="mm_fm350gl_port_types_vendorcheck"
+  SUBSYSTEMS=="usb", ATTRS{bInterfaceNumber}=="?*", ENV{.MM_USBIFNUM}="$attr{bInterfaceNumber}"
+
+  #AT+GTUSBMODE=40 (0e8d:7126)  RNDIS+AT+AP(GNSS)+META+DEBUG+NPT+ADB
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="00", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="01", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="02", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="03", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="04", SUBSYSTEM=="tty", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="05", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="06", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7126", ENV{.MM_USBIFNUM}=="07", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+
+  #AT+GTUSBMODE=41 (0e8d:7127)  RNDIS+AT+AP(GNSS)+META+DEBUG+NPT+ADB+AP(LOG)+AP(META)(default value)
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="00", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="01", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="02", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="03", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="04", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="05", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="06", SUBSYSTEM=="tty", ENV{ID_MM_PORT_TYPE_AT_PRIMARY}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="07", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="08", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+  ATTRS{idVendor}=="0e8d", ATTRS{idProduct}=="7127", ENV{.MM_USBIFNUM}=="09", SUBSYSTEM=="tty", ENV{ID_MM_PORT_IGNORE}="1"
+
+  GOTO="mm_fm350gl_port_types_end"
+
+  LABEL="mm_fm350gl_port_types_end"
+
+
diff --git a/src/plugins/fm350gl/mm-broadband-bearer-fm350gl.c b/src/plugins/fm350gl/mm-broadband-bearer-fm350gl.c
new file mode 100755
index 0000000..6fcf516
--- /dev/null
+++ b/src/plugins/fm350gl/mm-broadband-bearer-fm350gl.c
@@ -0,0 +1,619 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) PMGZED
+ * Copyright (C) ModemManager Team
+ */
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+
+#include <ModemManager.h>
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include <arpa/inet.h>
+#include <netinet/in.h>
+
+#include "mm-base-modem-at.h"
+#include "mm-broadband-bearer-fm350gl.h"
+#include "mm-log-object.h"
+
+
+
+static MMPort * dial_3gpp_finish (MMBroadbandBearer *self, GAsyncResult *res, GError **error);
+static void dial_3gpp (MMBroadbandBearer *self, MMBaseModem *modem, MMPortSerialAt *primary, guint cid, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
+static void get_ip_config_3gpp (MMBroadbandBearer *self, MMBroadbandModem *modem, MMPortSerialAt *primary, MMPortSerialAt *secondary, MMPort *data, guint cid, MMBearerIpFamily ip_family, GAsyncReadyCallback callback, gpointer user_data);
+static gboolean get_ip_config_3gpp_finish (MMBroadbandBearer *self, GAsyncResult *res, MMBearerIpConfig **ipv4_config, MMBearerIpConfig **ipv6_config, GError **error);
+static void disconnect_3gpp(MMBroadbandBearer* self, MMBroadbandModem* modem, MMPortSerialAt* primary, MMPortSerialAt* secondary, MMPort* data, guint cid, GAsyncReadyCallback callback, gpointer user_data); // behandelt den disconnect
+gboolean parse_ip(const gchar* response, MMBearerIpConfig* out_ip4_config, MMBearerIpConfig* out_ip6_config, GError** error);
+void deztohexip(gchar* dezstring, GString* output);
+
+G_DEFINE_TYPE (MMBroadbandBearerFM350GL, mm_broadband_bearer_fm350gl, MM_TYPE_BROADBAND_BEARER);
+
+struct _MMBroadbandBearerFM350GLPrivate {
+    /*-- Common stuff --*/
+    /* Data port used when modem is connected */
+    MMPort* port;
+    /* Current connection type */
+    ConnectionType connection_type;
+
+    /* PPP specific */
+    MMFlowControl flow_control;
+
+    /*-- 3GPP specific --*/
+    /* CID of the PDP context */
+    gint profile_id;
+};
+
+
+typedef struct {
+    MMBaseModem *modem;
+    MMPortSerialAt *primary;
+    GError *saved_error;
+    MMPortSerialAt* dial_port;
+    gboolean close_dial_port_on_exit;
+} Dial3gppContext;
+
+typedef struct {
+    MMBaseModem *modem;
+    MMPortSerialAt *primary;
+    MMPortSerialAt *secondary;
+    MMPort *data;
+    /* 3GPP-specific */
+    MMBearerIpFamily ip_family;
+} DetailedConnectContext;
+
+
+
+
+
+
+void
+mm_broadband_bearer_fm350gl_new (MMBroadbandModem *modem,
+                         MMBearerProperties *bearer_properties,
+                         GCancellable *cancellable,
+                         GAsyncReadyCallback callback,
+                         gpointer user_data)
+{
+    g_async_initable_new_async (
+        MM_TYPE_BROADBAND_BEARER_FM350GL,
+        G_PRIORITY_DEFAULT,
+        cancellable,
+        callback,
+        user_data,
+        MM_BASE_BEARER_MODEM,             modem,
+        MM_BASE_BEARER_CONFIG,            bearer_properties,
+        NULL);
+}
+
+
+
+
+	      
+MMBaseBearer * mm_broadband_bearer_fm350gl_new_finish (GAsyncResult *res, GError **error)
+{
+    GObject *bearer;
+    GObject *source;
+
+    source = g_async_result_get_source_object (res);
+    bearer = g_async_initable_new_finish (G_ASYNC_INITABLE (source), res, error);
+    g_object_unref (source);
+
+    if (!bearer)
+        return NULL;
+
+    /* Only export valid bearers */
+    mm_base_bearer_export (MM_BASE_BEARER (bearer));
+
+    return MM_BASE_BEARER (bearer);
+}
+
+
+
+static void
+mm_broadband_bearer_fm350gl_init (MMBroadbandBearerFM350GL *self)
+{
+    /* Initialize private data */
+    self->priv = G_TYPE_INSTANCE_GET_PRIVATE ((self),
+                                              MM_TYPE_BROADBAND_BEARER_FM350GL,
+                                              MMBroadbandBearerFM350GLPrivate);
+}
+
+
+
+static void
+mm_broadband_bearer_fm350gl_class_init (MMBroadbandBearerFM350GLClass *klass)
+{
+    MMBroadbandBearerClass *broadband_bearer_class = MM_BROADBAND_BEARER_CLASS (klass);
+
+    broadband_bearer_class->dial_3gpp = dial_3gpp;					
+    broadband_bearer_class->dial_3gpp_finish = dial_3gpp_finish;			
+    broadband_bearer_class->get_ip_config_3gpp = get_ip_config_3gpp;		
+    broadband_bearer_class->get_ip_config_3gpp_finish = get_ip_config_3gpp_finish;
+    broadband_bearer_class->disconnect_3gpp = disconnect_3gpp;
+}
+
+
+
+static void
+cgact_ready(MMBaseModem* modem,
+    GAsyncResult* res,
+    GTask* task)
+{
+    MMBroadbandBearer* self;
+
+    GError* error = NULL;
+
+    self = g_task_get_source_object(task);
+ 
+   
+    mm_base_modem_at_command_full_finish(modem, res, &error);
+
+    if (!error)
+    { }
+    else {
+        mm_obj_dbg(self, "PDP context deactivation failed (not fatal): %s", error->message);
+    }
+
+    g_task_return_boolean(task, TRUE);
+    g_object_unref(task);
+}
+static void
+disconnect_3gpp(MMBroadbandBearer* self,
+    MMBroadbandModem* modem,
+    MMPortSerialAt* primary,
+    MMPortSerialAt* secondary,
+    MMPort* data,
+    guint cid,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+    GTask* task;
+    gchar* command;
+
+    g_assert(primary != NULL);
+    command = g_strdup_printf("+CGACT=0,%d", cid);
+    task = g_task_new(self, NULL, callback, user_data);
+
+        mm_obj_dbg(self, "sending PDP context deactivation in primary port...");
+        mm_base_modem_at_command_full(MM_BASE_MODEM(g_object_ref(modem)),
+            primary,
+            command, //"Z0",
+            45,
+            FALSE,
+            FALSE, /* raw */
+            NULL, /* cancellable */
+            (GAsyncReadyCallback)cgact_ready,
+            task);
+
+
+        return;
+
+}
+
+
+
+static MMPort *
+dial_3gpp_finish (MMBroadbandBearer *self,
+                  GAsyncResult *res,
+                  GError **error)
+{
+    return g_task_propagate_pointer (G_TASK (res), error);
+}
+
+
+
+
+
+static void
+activate_pdp_finish (MMBaseModem *modem,
+           GAsyncResult *res,
+           GTask *task)
+{
+    Dial3gppContext *ctx;
+
+
+    ctx = g_task_get_task_data (task);
+    mm_base_modem_at_command_full_finish(modem, res, &ctx->saved_error);
+
+    g_task_return_pointer (task,
+                           g_object_ref (mm_base_modem_peek_best_data_port (modem, MM_PORT_TYPE_NET)), //return Port for IP Configuration (ethX) to -> dial_3gpp_finish
+                           g_object_unref);
+    g_object_unref (task);
+}
+
+
+static void
+dial_3gpp_context_free (Dial3gppContext *ctx)
+{
+    if (ctx->saved_error)
+        g_error_free (ctx->saved_error);
+    g_object_unref (ctx->primary);
+    g_object_unref (ctx->modem);
+    g_slice_free (Dial3gppContext, ctx);
+}
+
+
+static void
+dial_3gpp (MMBroadbandBearer *self,
+           MMBaseModem *modem,
+           MMPortSerialAt *primary,
+           guint cid,
+           GCancellable *cancellable,
+           GAsyncReadyCallback callback,
+           gpointer user_data)
+{
+    gchar *command;
+    Dial3gppContext *ctx;
+    GTask *task;
+
+    g_assert (primary != NULL);
+
+    ctx = g_slice_new0 (Dial3gppContext);
+    ctx->modem = g_object_ref (modem);
+    ctx->primary = g_object_ref (primary);
+	
+    task = g_task_new (self, cancellable, callback, user_data);
+    g_task_set_task_data (task, ctx, (GDestroyNotify)dial_3gpp_context_free);
+
+
+    command = g_strdup_printf ("+CGACT=1,%d", cid);
+    mm_base_modem_at_command_full (ctx->modem,
+                                   ctx->primary,
+                                   command,
+                                   MM_BASE_BEARER_DEFAULT_CONNECTION_TIMEOUT,
+                                   FALSE,
+                                   FALSE, /* raw */
+                                   NULL, /* cancellable */
+                                   (GAsyncReadyCallback)activate_pdp_finish,
+                                   task);
+    g_free (command);
+}
+
+
+void deztohexip(gchar* dezstring, GString* output)
+{
+    GString* dstr = g_string_new(dezstring);
+    gchar** parts;
+    int c,i;
+
+    parts = g_strsplit(dstr->str, ".", -1);
+    c = g_strv_length(parts);
+
+    for (i = 0; i < c; i++)
+    {
+        if (i == 0)
+        {
+            g_string_append(output, g_strdup_printf("%02x", atoi(parts[i])));
+        }
+        else
+        {
+            if (i%2==0){ g_string_append(output, ":"); }          
+            g_string_append(output, g_strdup_printf("%02x", atoi(parts[i])));
+        }
+
+    }
+  
+}
+
+
+gboolean
+parse_ip (const gchar *response,
+                               MMBearerIpConfig *out_ip4_config,
+                               MMBearerIpConfig *out_ip6_config,
+                               GError **error)
+{
+
+    gchar** data;
+    gchar** data1;
+    gchar** data2;
+    gchar* ip1;
+    gchar* ip2;
+    gchar* ipv4;
+    gchar* ipv6;
+    GString* gstmp;
+    int c;
+    GString* s;
+
+    g_return_val_if_fail(out_ip4_config, FALSE);
+    g_return_val_if_fail(out_ip6_config, FALSE);
+
+    if (!response || !g_str_has_prefix (response, "+CGPADDR")) {
+        g_set_error (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Missing +CGPADDR prefix");
+        return FALSE;
+    }
+
+    response = mm_strip_tag (response, "+CGPADDR: ");
+    
+    s=g_string_new(response);
+    g_string_replace(s,"\"","",-1);
+    data = g_strsplit(s->str, ",", -1);
+    c= g_strv_length(data);
+
+
+    if (c!=3) { g_set_error_literal (error, MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't match +CGPADDR reply");  return TRUE; }
+
+    ipv4 = NULL;
+    ipv6 = NULL;
+    ip1=data[1];
+    ip2=data[2];
+    g_free(data);
+
+
+    mm_bearer_ip_config_set_method (out_ip4_config, MM_BEARER_IP_METHOD_UNKNOWN);
+    mm_bearer_ip_config_set_method (out_ip6_config, MM_BEARER_IP_METHOD_UNKNOWN);
+
+    data1 = g_strsplit(ip1, ".", -1); 
+    c= g_strv_length(data1);
+    if(c<5 && c>1)
+    {
+	    ipv4=ip1; mm_bearer_ip_config_set_method (out_ip4_config, MM_BEARER_IP_METHOD_STATIC); 
+	    mm_bearer_ip_config_set_address (out_ip4_config, ipv4); 
+	    mm_bearer_ip_config_set_prefix (out_ip4_config, 32); 
+	    mm_bearer_ip_config_set_gateway(out_ip4_config, ipv4);
+    }
+    if(c>5)
+    {
+	    ipv6=ip1; mm_bearer_ip_config_set_method (out_ip6_config, MM_BEARER_IP_METHOD_DHCP);
+    }
+    g_free(data1);
+
+
+    data2 = g_strsplit(ip2, ".", -1);
+    c= g_strv_length(data2);
+    if(c<5 && c>1)            
+    {
+        ipv4=ip2; mm_bearer_ip_config_set_method (out_ip4_config, MM_BEARER_IP_METHOD_STATIC);
+        mm_bearer_ip_config_set_address (out_ip4_config, ipv4);
+        mm_bearer_ip_config_set_prefix (out_ip4_config, 32);
+        mm_bearer_ip_config_set_gateway(out_ip4_config, ipv4);
+    }
+    if(c>5)
+    {
+        ipv6=ip2; mm_bearer_ip_config_set_method (out_ip6_config, MM_BEARER_IP_METHOD_DHCP);
+        gstmp = g_string_new("");
+        deztohexip(ipv6, gstmp);
+        ipv6 = gstmp->str;
+    }
+    g_free(data2);
+
+    mm_obj_info (NULL, "ipv4: %s",ipv4);
+    mm_obj_info (NULL, "ipv6: %s",ipv6);
+    
+
+    return TRUE;
+}
+
+
+typedef struct {
+    MMBaseModem *modem;
+    MMPortSerialAt *primary;
+    guint cid;
+    MMBearerIpConfig *ipv4_config;
+    MMBearerIpConfig* ipv6_config;
+
+} GetIpConfig3gppContext;
+
+static void
+get_ip_config_context_free (GetIpConfig3gppContext *ctx)
+{
+    g_object_unref (ctx->primary);
+    g_object_unref (ctx->modem);
+    g_slice_free (GetIpConfig3gppContext, ctx);
+    g_object_unref (ctx->ipv4_config);
+    g_object_unref (ctx->ipv6_config);
+}
+
+static gboolean
+get_ip_config_3gpp_finish (MMBroadbandBearer *self,
+                           GAsyncResult *res,
+                           MMBearerIpConfig **ipv4_config,
+                           MMBearerIpConfig **ipv6_config,
+                           GError **error)
+{
+    MMBearerConnectResult *configs;
+    MMBearerIpConfig *ipv4, *ipv6;
+
+    configs = g_task_propagate_pointer (G_TASK (res), error);
+    if (!configs)
+        return FALSE;
+
+
+    ipv4 = mm_bearer_connect_result_peek_ipv4_config (configs);
+    ipv6 = mm_bearer_connect_result_peek_ipv6_config (configs);
+    g_assert (ipv4 || ipv6);
+    if (ipv4_config && ipv4)
+        *ipv4_config = g_object_ref (ipv4);
+    if (ipv6_config && ipv6)
+        *ipv6_config = g_object_ref (ipv6);
+
+    mm_bearer_connect_result_unref (configs);
+    return TRUE;
+}
+
+
+
+static void ip_config_dns_gw_ready (MMBaseModem *modem, GAsyncResult *res,  GTask *task)
+{
+    GetIpConfig3gppContext *ctx;
+    const gchar *response;
+    GError *error = NULL;
+    MMBearerConnectResult *connect_result;
+
+    gchar* dns1;
+    gchar* dns2;
+    gchar* dnsv61;
+    gchar* dnsv62;
+    const gchar* dns[3] = { 0 };
+    const gchar* dnsv6[3] = { 0 };
+    GString* s;
+    gchar** data;
+    int c;
+    GString* gstmp;
+
+    ctx = g_task_get_task_data(task);
+    response = mm_base_modem_at_command_full_finish(modem, res, &error);
+
+    if (!response || !g_str_has_prefix (response, "+CGCONTRDP")) {
+        g_task_return_new_error(task, MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Missing +cgcontrdp prefix");
+        return;
+    }
+
+    response = mm_strip_tag (response, "+CGCONTRDP: ");
+    
+    s=g_string_new(response);
+    g_string_replace(s,"\"","",-1);
+
+
+
+    data = g_strsplit(s->str, ",", -1);
+    c= g_strv_length(data);
+
+
+    if (c<30) { g_task_return_new_error(task, MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Couldn't match +cgcontrdp reply");   return; }
+
+    dns1=data[5];
+    dns2=data[6];
+    dnsv61=data[28];
+    dnsv62=data[29];
+    g_free(data);
+
+    gstmp = g_string_new("");
+    deztohexip(dnsv61, gstmp);
+    dnsv61 = gstmp->str;
+
+    gstmp = g_string_new("");
+    deztohexip(dnsv62, gstmp);
+    dnsv62 = gstmp->str;
+
+
+    mm_obj_info (NULL, "dns1: %s",dns1);
+    mm_obj_info (NULL, "dns2: %s",dns2);
+    mm_obj_info (NULL, "dnsv61: %s", dnsv61);
+    mm_obj_info (NULL, "dnsv61: %s", dnsv62);
+
+
+	
+	dns[0]= dns1;
+	dns[1]= dns2;
+
+    dnsv6[0] = dnsv61;
+    dnsv6[1] = dnsv62;
+
+	mm_bearer_ip_config_set_dns(ctx->ipv4_config, (const gchar **) &dns);
+    mm_bearer_ip_config_set_dns(ctx->ipv6_config, (const gchar **) &dnsv6);
+
+    connect_result = mm_bearer_connect_result_new(mm_base_modem_peek_best_data_port(modem, MM_PORT_TYPE_NET), ctx->ipv4_config, ctx->ipv6_config); 
+
+    g_task_return_pointer (task,
+                           connect_result,
+                           (GDestroyNotify)mm_bearer_connect_result_unref);
+
+
+    g_object_unref(task);
+}
+
+
+
+static void
+ip_config_ipaddress_ready (MMBaseModem *modem,
+                 GAsyncResult *res,
+                 GTask *task)
+{
+    gchar* command;
+    const gchar *response;
+    GError *error = NULL;
+    GetIpConfig3gppContext *ctx;
+    ctx=g_task_get_task_data (task);
+    ctx->ipv4_config = mm_bearer_ip_config_new ();
+    ctx->ipv6_config = mm_bearer_ip_config_new ();
+    response = mm_base_modem_at_command_full_finish (modem, res, &error);
+
+    if (!error)
+    {
+    }
+    else {
+        mm_obj_dbg(NULL, "AT+CGPADDR Failed no IP Data: %s", error->message);
+        g_task_return_error(task, error);
+        return;
+    }
+
+
+    if (!parse_ip (response, ctx->ipv4_config, ctx->ipv6_config, &error))
+    {
+        g_task_return_error (task, error);
+        
+        goto out;
+    }    
+
+    
+    command = g_strdup_printf ("at+cgcontrdp");
+    mm_base_modem_at_command_full (
+        MM_BASE_MODEM (modem),
+        ctx->primary,
+        command,
+        3,
+        FALSE,
+        FALSE, /* raw */
+        NULL, /* cancellable */
+        (GAsyncReadyCallback)ip_config_dns_gw_ready,
+        task);
+    g_free (command);
+out:
+
+}
+
+
+
+static void
+get_ip_config_3gpp (MMBroadbandBearer *self,
+                    MMBroadbandModem *modem,
+                    MMPortSerialAt *primary,
+                    MMPortSerialAt *secondary,
+                    MMPort *data,
+                    guint cid,
+                    MMBearerIpFamily ip_family,
+                    GAsyncReadyCallback callback,
+                    gpointer user_data)
+{
+    GetIpConfig3gppContext *ctx;
+    GTask *task;
+    gchar *command;
+
+    mm_obj_info (NULL, "3gpp Dataport:: %s",  mm_port_get_device (data));
+    ctx = g_slice_new0 (GetIpConfig3gppContext);
+    ctx->modem = MM_BASE_MODEM (g_object_ref (modem));
+    ctx->primary = g_object_ref (primary);
+    ctx->cid = cid;
+
+    task = g_task_new (self, NULL, callback, user_data);
+    g_task_set_task_data (task, ctx, (GDestroyNotify)get_ip_config_context_free);
+
+    command = g_strdup_printf ("AT+CGPADDR=%d", cid);
+    mm_base_modem_at_command_full (
+        MM_BASE_MODEM (modem),
+        primary,
+        command,
+        3,
+        FALSE,
+        FALSE, /* raw */
+        NULL, /* cancellable */
+        (GAsyncReadyCallback)ip_config_ipaddress_ready,
+        task);
+    g_free (command);
+}
+
diff --git a/src/plugins/fm350gl/mm-broadband-bearer-fm350gl.h b/src/plugins/fm350gl/mm-broadband-bearer-fm350gl.h
new file mode 100755
index 0000000..faad07c
--- /dev/null
+++ b/src/plugins/fm350gl/mm-broadband-bearer-fm350gl.h
@@ -0,0 +1,82 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ */
+
+#ifndef MM_BROADBAND_BEARER_FM350GL_H
+#define MM_BROADBAND_BEARER_FM350GL_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-broadband-bearer.h"
+#include "mm-broadband-modem-fm350gl.h"
+
+#define MM_TYPE_BROADBAND_BEARER_FM350GL            (mm_broadband_bearer_fm350gl_get_type ())
+#define MM_BROADBAND_BEARER_FM350GL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BROADBAND_BEARER_FM350GL, MMBroadbandBearerFM350GL))
+#define MM_BROADBAND_BEARER_FM350GL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BROADBAND_BEARER_FM350GL, MMBroadbandBearerFM350GLClass))
+#define MM_IS_BROADBAND_BEARER_FM350GL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BROADBAND_BEARER_FM350GL))
+#define MM_IS_BROADBAND_BEARER_FM350GL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BROADBAND_BEARER_FM350GL))
+#define MM_BROADBAND_BEARER_FM350GL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BROADBAND_BEARER_FM350GL, MMBroadbandBearerFM350GLClass))
+
+GType mm_broadband_bearer_fm350gl_get_type (void);
+
+typedef struct _MMBroadbandBearerFM350GL MMBroadbandBearerFM350GL;
+typedef struct _MMBroadbandBearerFM350GLClass MMBroadbandBearerFM350GLClass;
+typedef struct _MMBroadbandBearerFM350GLPrivate MMBroadbandBearerFM350GLPrivate;
+
+
+
+typedef enum {
+    CONNECTION_TYPE_NONE,
+    CONNECTION_TYPE_3GPP,
+    CONNECTION_TYPE_CDMA,
+} ConnectionType;
+
+struct _MMBroadbandBearerFM350GL {
+    /*-- Common stuff --*/
+    /* Data port used when modem is connected */
+    MMPort *port;
+    /* Current connection type */
+    ConnectionType connection_type;
+
+    /* PPP specific */
+//    MMFlowControl flow_control;
+
+    /*-- 3GPP specific --*/
+    /* CID of the PDP context */
+    gint profile_id;
+
+    MMBroadbandBearer parent;
+    MMBroadbandBearerFM350GLPrivate *priv;
+};
+
+struct _MMBroadbandBearerFM350GLClass {
+    MMBroadbandBearerClass parent;
+};
+
+
+
+void mm_broadband_bearer_fm350gl_new (MMBroadbandModem *modem,
+                         MMBearerProperties *bearer_properties,
+                         GCancellable *cancellable,
+                         GAsyncReadyCallback callback,
+                         gpointer user_data);
+
+MMBaseBearer *mm_broadband_bearer_fm350gl_new_finish (GAsyncResult *res,
+                                                     GError **error);
+
+
+#endif /* MM_BROADBAND_BEARER_FM350GL_H */
diff --git a/src/plugins/fm350gl/mm-broadband-modem-fm350gl.c b/src/plugins/fm350gl/mm-broadband-modem-fm350gl.c
new file mode 100755
index 0000000..aee7d3c
--- /dev/null
+++ b/src/plugins/fm350gl/mm-broadband-modem-fm350gl.c
@@ -0,0 +1,778 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) PMGZED
+ * Copyright (C) ModemManager Team
+ */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#include "ModemManager.h"
+#include "mm-broadband-modem-fm350gl.h"
+#include "mm-broadband-bearer-fm350gl.h"
+#include "mm-base-modem-at.h"
+#include "mm-log-object.h"
+#include "mm-modem-helpers.h"
+#include "mm-common-helpers.h"
+#include "mm-errors-types.h"
+#include "mm-iface-modem.h"
+#include "mm-iface-modem-3gpp.h"
+#include "mm-iface-modem-time.h"
+#include "mm-log.h"
+
+#include "mm-iface-modem-3gpp-profile-manager.h"
+
+
+
+
+static void iface_modem_init (MMIfaceModem *iface); 	
+static void iface_modem_3gpp_profile_manager_init(MMIfaceModem3gppProfileManager* iface);
+
+
+static void load_supported_modes (MMIfaceModem *self, GAsyncReadyCallback callback, gpointer user_data);
+static GArray * load_supported_modes_finish (MMIfaceModem *self, GAsyncResult *res, GError **error);
+static gboolean load_current_modes_finish (MMIfaceModem *self, GAsyncResult *res, MMModemMode *allowed, MMModemMode *preferred, GError **error);
+static void load_current_modes (MMIfaceModem *self, GAsyncReadyCallback callback, gpointer user_data);
+static MMBaseBearer * modem_create_bearer_finish (MMIfaceModem *self, GAsyncResult *res, GError **error);
+static void modem_create_bearer (MMIfaceModem *self, MMBearerProperties *properties, GAsyncReadyCallback callback, gpointer user_data);
+static void enabling_modem_init(MMBroadbandModem* self, GAsyncReadyCallback  callback, gpointer user_data);                                                             // Initialisierung ATZ0 anstelle von ATZ
+static void modem_3gpp_profile_manager_check_format(MMIfaceModem3gppProfileManager* self, MMBearerIpFamily ip_type, GAsyncReadyCallback callback, gpointer user_data);  //min cid. CID sollte >0 sein
+static gboolean modem_set_current_modes_finish(MMIfaceModem* self, GAsyncResult* res, GError** error);
+static void modem_set_current_modes(MMIfaceModem* _self, MMModemMode allowed, MMModemMode preferred, GAsyncReadyCallback  callback, gpointer  user_data);
+static void load_supported_bands(MMIfaceModem* self, GAsyncReadyCallback callback, gpointer user_data);
+static GArray* load_supported_bands_finish(MMIfaceModem* self, GAsyncResult* res, GError** error);
+static void load_current_bands(MMIfaceModem* self, GAsyncReadyCallback callback, gpointer user_data);
+static GArray* load_current_bands_finish(MMIfaceModem* self, GAsyncResult* res, GError** error);
+static void set_current_bands(MMIfaceModem* self, GArray* bands_array, GAsyncReadyCallback  callback, gpointer user_data);
+static gboolean set_current_bands_finish(MMIfaceModem* self, GAsyncResult* res, GError** error);
+static void load_signal_quality(MMIfaceModem* self, GAsyncReadyCallback callback, gpointer user_data); // std geht auch bei dieser wird mit +CSQ abgefragt
+static guint load_signal_quality_finish(MMIfaceModem* self,  GAsyncResult* res, GError** error);
+
+
+
+G_DEFINE_TYPE_EXTENDED (MMBroadbandModemFM350GL, mm_broadband_modem_fm350gl, MM_TYPE_BROADBAND_MODEM, 0,
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_IFACE_MODEM, iface_modem_init)
+                        G_IMPLEMENT_INTERFACE(MM_TYPE_IFACE_MODEM_3GPP_PROFILE_MANAGER, iface_modem_3gpp_profile_manager_init)
+
+			);
+
+
+MMBroadbandModemFM350GL *mm_broadband_modem_FM350GL_new (const gchar *device,
+                                                       const gchar *physdev,
+                                                       const gchar **drivers,
+                                                       const gchar *plugin,
+                                                       guint16 vendor_id,
+                                                       guint16 product_id)
+{
+    return g_object_new (MM_TYPE_BROADBAND_MODEM_FM350GL,
+                         MM_BASE_MODEM_DEVICE, device,
+			             MM_BASE_MODEM_PHYSDEV, physdev,
+                         MM_BASE_MODEM_DRIVERS, drivers,
+                         MM_BASE_MODEM_PLUGIN, plugin,
+                         MM_BASE_MODEM_VENDOR_ID, vendor_id,
+                         MM_BASE_MODEM_PRODUCT_ID, product_id,
+                         MM_BASE_MODEM_DATA_NET_SUPPORTED, TRUE,
+                         MM_BASE_MODEM_DATA_TTY_SUPPORTED, FALSE,
+                         NULL);
+}
+
+
+
+static void
+
+iface_modem_init (MMIfaceModem *iface)
+{
+    iface->load_supported_modes = load_supported_modes;
+    iface->load_supported_modes_finish = load_supported_modes_finish;
+    iface->load_current_modes = load_current_modes;
+    iface->load_current_modes_finish = load_current_modes_finish;
+    iface->create_bearer = modem_create_bearer;
+    iface->create_bearer_finish = modem_create_bearer_finish;
+    iface->set_current_modes = modem_set_current_modes;
+    iface->set_current_modes_finish = modem_set_current_modes_finish;
+    iface->load_supported_bands = load_supported_bands;
+    iface->load_supported_bands_finish = load_supported_bands_finish;
+    iface->load_current_bands = load_current_bands;
+    iface->load_current_bands_finish = load_current_bands_finish;
+    iface->set_current_bands = set_current_bands;
+    iface->set_current_bands_finish = set_current_bands_finish;
+    iface->load_signal_quality = load_signal_quality;
+    iface->load_signal_quality_finish = load_signal_quality_finish;
+}
+
+
+static void
+iface_modem_3gpp_profile_manager_init(MMIfaceModem3gppProfileManager* iface)
+{
+    iface->check_format = modem_3gpp_profile_manager_check_format;                     
+}
+
+static void
+mm_broadband_modem_fm350gl_init (MMBroadbandModemFM350GL *self) //muss da sein sonst werden die berarer funktionen vom individuellen bearer nicht genutzt?
+{
+
+}
+
+static void
+mm_broadband_modem_fm350gl_class_init (MMBroadbandModemFM350GLClass *klass)
+{
+    klass->enabling_modem_init = enabling_modem_init; 
+}
+
+
+static void
+enabling_modem_init(MMBroadbandModem* self,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+    MMPortSerialAt* primary;
+
+    primary = mm_base_modem_peek_port_primary(MM_BASE_MODEM(self));
+    if (!primary) {
+        g_task_report_new_error(self, callback, user_data, enabling_modem_init,
+            MM_CORE_ERROR, MM_CORE_ERROR_FAILED,
+            "Failed to run init command: primary port missing");
+        return;
+    }
+    mm_base_modem_at_command_full(MM_BASE_MODEM(self),  primary, "Z0", 6, FALSE, FALSE, NULL, /* cancellable */ callback, user_data);
+}
+
+
+static GArray *
+load_supported_modes_finish (MMIfaceModem *self,
+                             GAsyncResult *res,
+                             GError **error)
+{
+    return g_task_propagate_pointer (G_TASK (res), error);
+}
+
+
+static void
+load_supported_modes (MMIfaceModem *self,
+                      GAsyncReadyCallback callback,
+                      gpointer user_data)
+{
+
+    GTask *task;
+    MMModemModeCombination mode;
+	GArray *combinations;
+    combinations = g_array_sized_new (FALSE, FALSE, sizeof (MMModemModeCombination),4);
+	
+        mode.allowed = (MM_MODEM_MODE_3G);
+        mode.preferred = MM_MODEM_MODE_NONE;
+        g_array_append_val (combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_4G);
+        mode.preferred = MM_MODEM_MODE_NONE;
+        g_array_append_val (combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_5G);
+        mode.preferred = MM_MODEM_MODE_NONE;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G);
+        mode.preferred = MM_MODEM_MODE_3G;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G);
+        mode.preferred = MM_MODEM_MODE_4G;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_5G);
+        mode.preferred = MM_MODEM_MODE_3G;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_5G);
+        mode.preferred = MM_MODEM_MODE_5G;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+        mode.preferred = MM_MODEM_MODE_4G;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+        mode.preferred = MM_MODEM_MODE_5G;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+        mode.preferred = MM_MODEM_MODE_3G;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+        mode.preferred = MM_MODEM_MODE_4G;
+        g_array_append_val(combinations, mode);
+        mode.allowed = (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G);
+        mode.preferred = MM_MODEM_MODE_5G;
+        g_array_append_val(combinations, mode);
+
+        task = g_task_new(self, NULL, callback, user_data);
+	    g_task_return_pointer (task, combinations, (GDestroyNotify) g_array_unref);
+}
+
+static gboolean
+load_current_modes_finish (MMIfaceModem *self,
+                           GAsyncResult *res,
+                           MMModemMode *allowed,
+                           MMModemMode *preferred,
+                           GError **error)
+{
+        gint mode;
+        gchar** data;
+        const gchar* response;
+        GString* s;
+        int c;
+        g_autoptr(GError)   errorcf = NULL;
+
+        *allowed = MM_MODEM_MODE_5G | MM_MODEM_MODE_4G | MM_MODEM_MODE_3G;
+        *preferred = MM_MODEM_MODE_NONE;
+
+        mode = -1;
+        response = mm_base_modem_at_command_full_finish(MM_BASE_MODEM(self), res, &errorcf);
+        if (!response) { return TRUE; }
+        response = mm_strip_tag(response, "+GTACT: ");
+
+        s = g_string_new(response);
+        data = g_strsplit(s->str, ",", -1);
+        c = g_strv_length(data);
+        if (c<2) { return TRUE; }
+
+        if (g_ascii_strcasecmp(data[0], "1") == 0) { *allowed = MM_MODEM_MODE_3G; }
+        if (g_ascii_strcasecmp(data[0], "2") == 0) { *allowed = MM_MODEM_MODE_4G;}
+        if (g_ascii_strcasecmp(data[0], "4") == 0) { *allowed = MM_MODEM_MODE_3G | MM_MODEM_MODE_4G; }
+        if (g_ascii_strcasecmp(data[0], "14") == 0) { *allowed = MM_MODEM_MODE_5G; }
+        if (g_ascii_strcasecmp(data[0], "16") == 0) { *allowed = MM_MODEM_MODE_3G| MM_MODEM_MODE_5G; }
+        if (g_ascii_strcasecmp(data[0], "17") == 0) { *allowed = MM_MODEM_MODE_4G | MM_MODEM_MODE_5G; }
+        if (g_ascii_strcasecmp(data[0], "20") == 0) { *allowed = MM_MODEM_MODE_3G | MM_MODEM_MODE_4G |MM_MODEM_MODE_5G; }
+
+        if (g_ascii_strcasecmp(data[1], "2") == 0) { *preferred = MM_MODEM_MODE_3G; }
+        if (g_ascii_strcasecmp(data[1], "3") == 0) { *preferred = MM_MODEM_MODE_4G; }
+        if (g_ascii_strcasecmp(data[1], "6") == 0) { *preferred = MM_MODEM_MODE_5G; }
+
+
+        return TRUE;
+
+
+    
+    g_set_error (error,
+                 MM_CORE_ERROR,
+                 MM_CORE_ERROR_FAILED,
+                 "Failed to parse mode/tech response: Unexpected mode '%d'", mode);
+    return FALSE;
+}
+
+static void
+load_current_modes (MMIfaceModem *self,
+                    GAsyncReadyCallback callback,
+                    gpointer user_data)
+{
+
+
+    mm_base_modem_at_command (MM_BASE_MODEM (self),
+                              "AT+GTACT?", 
+                              3,
+                              FALSE,
+                              callback,
+                              user_data);
+}
+
+
+static void modem_set_current_modes(MMIfaceModem* _self, MMModemMode  allowed, MMModemMode  preferred, GAsyncReadyCallback callback, gpointer  user_data)
+{
+    gchar* command;
+    int Rat = 20;
+    int pref = 0;
+
+    if (allowed == (MM_MODEM_MODE_3G)) { Rat = 1; }
+    if (allowed == (MM_MODEM_MODE_4G)) { Rat = 2; }
+    if (allowed == (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G)) { Rat = 4; }
+    if (allowed == (MM_MODEM_MODE_5G)) { Rat = 14; }
+    if (allowed == (MM_MODEM_MODE_5G | MM_MODEM_MODE_3G)) { Rat = 16; }
+    if (allowed == (MM_MODEM_MODE_4G | MM_MODEM_MODE_5G)) { Rat = 17;  }
+    if (allowed == (MM_MODEM_MODE_3G | MM_MODEM_MODE_4G | MM_MODEM_MODE_5G)) { Rat = 20; }
+   
+    if (preferred == MM_MODEM_MODE_3G) { pref = 2;}
+    if (preferred == MM_MODEM_MODE_4G) { pref = 3;}
+    if (preferred == MM_MODEM_MODE_5G) { pref = 6;}
+
+ 
+
+    if (pref == 0){ command = g_strdup_printf("+GTACT=%d", Rat); } else { command = g_strdup_printf("+GTACT=%d,%d", Rat, pref); }
+
+    mm_base_modem_at_command(MM_BASE_MODEM(_self), command, 3, FALSE, callback, user_data);
+}
+
+static gboolean modem_set_current_modes_finish(MMIfaceModem* self, GAsyncResult* res, GError** error)
+{
+    return g_task_propagate_boolean(G_TASK(res), error);
+}
+
+
+static void
+load_signal_quality(MMIfaceModem* self, GAsyncReadyCallback callback, gpointer user_data)
+{
+    mm_base_modem_at_command(MM_BASE_MODEM(self), "+CSQ", 3, FALSE, callback, user_data);
+}
+
+static guint
+load_signal_quality_finish(MMIfaceModem* self,
+    GAsyncResult* res,
+    GError** error)
+{
+    gint quality = 0;
+    gint         ber;
+    const gchar* response, * p;
+  
+
+    response = mm_base_modem_at_command_finish(MM_BASE_MODEM(self), res, error);
+    if (!response)
+        return 0;
+
+
+
+    if (!response[0]) {
+        return 0;
+    }
+
+    p = mm_strip_tag(response, "+CSQ:");
+    if (sscanf(p, "%d, %d", &quality, &ber)) {
+        if (quality != 99)
+            quality = CLAMP(quality, 0, 31) * 100 / 31;
+        else
+            quality = 0;
+        return quality;
+    }
+
+    return 0;
+}
+
+
+static GArray* load_supported_bands_finish(MMIfaceModem* self, GAsyncResult* res, GError** error)
+{
+    return g_task_propagate_pointer(G_TASK(res), error);
+}
+
+
+static void load_supported_bands_done(MMIfaceModem* self, GAsyncResult* res, GTask* task)
+{
+    const gchar* response;
+    GError* error = NULL;
+    int i, tmp;
+    GString* stmp;
+    gchar* umts_band;
+    gchar* lte_band;
+    gchar* nr_band;
+    gchar** umtsbands;
+    gchar** lteband;
+    gchar** nrband;
+    GArray* bands;
+    gchar** parts;
+    int c, cumts, clte, cnr;
+    GString* s;
+
+
+    response = mm_base_modem_at_command_finish(MM_BASE_MODEM(self), res, &error);
+    if (!response) {
+        g_task_return_error(task, error);
+        g_object_unref(task);
+        return;
+    }
+    
+    response = mm_strip_tag(response, "+GTACT: ");
+
+    s = g_string_new(response);
+    g_string_replace(s, ")", "", -1);
+    g_string_replace(s, "(", "|", -1);  
+    parts = g_strsplit(s->str, "|", -1);
+    c = g_strv_length(parts);
+
+    if (c != 10) {
+        g_task_return_new_error(  task,  MM_CORE_ERROR,  MM_CORE_ERROR_FAILED, "Failed to parse supported bands response");
+        g_object_unref(task);
+        return;
+    }
+    
+    umts_band = parts[5];       
+    lte_band = parts[6];        
+    nr_band = parts[9];        
+ 
+
+    umtsbands = g_strsplit(umts_band, ",", -1);
+    lteband = g_strsplit(lte_band, ",", -1);
+    nrband = g_strsplit(nr_band, ",", -1);
+
+    cumts = g_strv_length(umtsbands)-1;
+    clte = g_strv_length(lteband)-1;
+    cnr = g_strv_length(nrband);
+ 
+    bands = g_array_new(FALSE, FALSE, sizeof(MMModemBand));
+
+    for (i = 0; i < cumts; i++)
+    {
+        tmp = atoi(umtsbands[i]);
+        bands = g_array_append_val(bands, tmp);
+
+    }
+    for (i = 0; i < clte; i++)
+    {
+        stmp = g_string_new(lteband[i]);
+        g_string_erase(stmp, 0, 1);
+        tmp = atoi(stmp->str)+30;
+        bands = g_array_append_val(bands, tmp);
+    }
+    for (i = 0; i < cnr; i++)
+    {
+        stmp = g_string_new(nrband[i]);
+        g_string_erase(stmp, 0, 1);
+        tmp = atoi(stmp->str) + 300;
+        bands = g_array_append_val(bands, tmp);
+    }
+
+    g_task_return_pointer(task, bands, (GDestroyNotify)g_array_unref);
+    g_object_unref(task);
+}
+
+
+
+static void load_supported_bands(MMIfaceModem* self, GAsyncReadyCallback callback, gpointer user_data)
+{
+    GTask* task;
+    task = g_task_new(self, NULL, callback, user_data);
+
+    mm_base_modem_at_command(
+        MM_BASE_MODEM(self),
+        "+GTACT=?",
+        3,
+        FALSE,
+        (GAsyncReadyCallback)load_supported_bands_done,
+        task);
+}
+
+
+
+static GArray* load_current_bands_finish(MMIfaceModem* self, GAsyncResult* res, GError** error)
+{
+    return g_task_propagate_pointer(G_TASK(res), error);
+}
+
+static void load_current_bands_done(MMIfaceModem* self, GAsyncResult* res, GTask* task)
+{
+    const gchar* response;
+    GError* error = NULL;
+    int c, i, tmp, count;
+    GArray* bands;
+    GString* s;
+    gchar** parts;
+
+    response = mm_base_modem_at_command_finish(MM_BASE_MODEM(self), res, &error);
+    if (!response) {
+        g_task_return_error(task, error);
+        g_object_unref(task);
+        return;
+    }
+
+    response = mm_strip_tag(response, "+GTACT: ");
+
+    s = g_string_new(response);
+    parts = g_strsplit(s->str, ",", -1);
+    c = g_strv_length(parts);
+
+
+    if (c < 4) {
+        g_task_return_new_error(task, MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Failed to parse supported bands response");
+        g_object_unref(task);
+        return;
+    }
+
+
+    count = g_strv_length(parts);
+
+    bands = g_array_new(FALSE, FALSE, sizeof(MMModemBand));
+
+   
+
+
+    for (i = 3; i < count; i++)
+    {
+        tmp = atoi(parts[i]);
+        if (tmp >= 100 && tmp < 200) { tmp = tmp - 100 + 30; }
+        if (tmp >= 500 && tmp < 600) { tmp = tmp - 500 + 300; } if (tmp >= 5000 && tmp < 6000) { tmp = tmp - 5000 + 300; }
+
+        bands = g_array_append_val(bands, tmp);
+    }
+   
+
+    g_task_return_pointer(task, bands, (GDestroyNotify)g_array_unref);
+    g_object_unref(task);
+}
+
+static void load_current_bands(MMIfaceModem* self, GAsyncReadyCallback callback, gpointer user_data)
+{  
+    GTask* task;
+
+    task = g_task_new(self, NULL, callback, user_data);
+
+    mm_base_modem_at_command(
+        MM_BASE_MODEM(self),
+        "+GTACT?",
+        3,
+        FALSE,
+        (GAsyncReadyCallback)load_current_bands_done,
+        task);  
+}
+
+
+
+static gboolean set_current_bands_finish(MMIfaceModem* self, GAsyncResult* res, GError** error)
+{
+    return g_task_propagate_boolean(G_TASK(res), error);
+}
+
+
+static void set_current_bands_set_finish(MMBaseModem* self, GAsyncResult* res, GTask* task)
+{
+    const gchar* response;
+    GError* error = NULL;
+    response = mm_base_modem_at_command_finish(MM_BASE_MODEM(self), res, &error);
+    if (!response) {
+        g_task_return_error(task, error);
+        g_object_unref(task);
+        return;
+    }
+    g_task_return_boolean(task, TRUE);
+    g_object_unref(task);
+}
+
+static void set_current_bands_get_current_rats(MMBaseModem* self, GAsyncResult* res, GTask* task)
+{
+    GString* s;
+
+    GArray* ctx;
+    gchar** parts;
+    int c,i,j,b;
+    GString* newcommand;
+
+    const gchar* response;
+    GError* error = NULL;
+
+    ctx = g_task_get_task_data(task);
+    response = mm_base_modem_at_command_finish(MM_BASE_MODEM(self), res, &error);
+    if (!response) {
+        g_task_return_error(task, error);
+        g_object_unref(task);
+        return;
+    }
+
+    response = mm_strip_tag(response, "+GTACT: ");
+    s = g_string_new(response);
+    parts = g_strsplit(s->str, ",", -1);
+    c = g_strv_length(parts);
+    if (c < 3)
+    {
+        g_task_return_new_error(task, MM_CORE_ERROR, MM_CORE_ERROR_FAILED, "Failed to parse Rats response");
+        g_object_unref(task);
+        return;
+    }
+
+    newcommand = g_string_new("AT+GTACT=");
+    g_string_append(newcommand, parts[0]);
+    g_string_append(newcommand, ",");
+    g_string_append(newcommand, parts[1]);
+    g_string_append(newcommand, ",");
+    g_string_append(newcommand, parts[2]);
+
+
+
+    j = ctx->len;
+
+    for (i=0;i<j;i++)
+    {
+        b = g_array_index(ctx, MMModemBand, i);
+        if (b > 0 && b < 30)
+        {
+            g_string_append(newcommand, ",");
+            g_string_append(newcommand, g_strdup_printf("%i", b));          
+            continue;
+        }
+        if (b > 30 && b < 300)
+        {
+            b = b - 30 + 100;
+            g_string_append(newcommand, ",");
+            g_string_append(newcommand, g_strdup_printf("%i", b));
+            continue;
+        }
+        if (b > 30 && b < 599)
+        {
+            b = b - 300; if ( b>0 && b <10 ) {b=b + 500;} else {b=b + 5000;}
+            g_string_append(newcommand, ",");
+            g_string_append(newcommand, g_strdup_printf("%i", b));
+            continue;
+        }
+
+    }
+
+    mm_base_modem_at_command(MM_BASE_MODEM(self),
+        newcommand->str,
+        3,
+        TRUE, 
+        (GAsyncReadyCallback)set_current_bands_set_finish,
+        task);
+
+    return;
+}
+
+
+
+static void set_current_bands_context_free(GArray* ctx)
+{
+
+}
+
+static void set_current_bands(MMIfaceModem* self, GArray* bands_array, GAsyncReadyCallback  callback, gpointer user_data)
+{
+    GTask* task;
+    task = g_task_new(self, NULL, callback, user_data);
+
+    g_task_set_task_data(task, bands_array, (GDestroyNotify)set_current_bands_context_free);
+
+    mm_base_modem_at_command(MM_BASE_MODEM(self),
+        "AT+GTACT?",
+        3,
+        TRUE, 
+        (GAsyncReadyCallback)set_current_bands_get_current_rats,
+        task);
+}
+
+
+
+
+static MMBaseBearer *
+modem_create_bearer_finish (MMIfaceModem *self,
+                            GAsyncResult *res,
+                            GError **error)
+{
+    return g_task_propagate_pointer (G_TASK (res), error);
+}
+
+static void
+broadband_bearer_fm350gl_new_ready (GObject *source,
+                                   GAsyncResult *res,
+                                   GTask *task)
+{
+    MMBaseBearer *bearer = NULL;
+    GError *error = NULL;
+
+    bearer = mm_broadband_bearer_fm350gl_new_finish (res, &error);
+    if (!bearer)
+        g_task_return_error (task, error);
+    else
+        g_task_return_pointer (task, bearer, g_object_unref);
+
+    g_object_unref (task);
+}
+
+static void
+modem_create_bearer (MMIfaceModem *self,
+                     MMBearerProperties *props,
+                     GAsyncReadyCallback callback,
+                     gpointer user_data)
+{
+    GTask *task;
+    task = g_task_new (self, NULL, callback, user_data);
+
+    mm_broadband_bearer_fm350gl_new (MM_BROADBAND_MODEM (self),
+                             props,
+                             NULL, /* cancellable */
+                             (GAsyncReadyCallback)broadband_bearer_fm350gl_new_ready,
+                             task);
+}
+
+
+
+
+typedef struct {                    
+    MMBearerIpFamily ip_type;
+    guint            min_profile_id;
+    guint            max_profile_id;
+} CheckFormatContext;
+
+static void
+check_format_context_free(CheckFormatContext* ctx)
+{
+    g_slice_free(CheckFormatContext, ctx);
+}
+
+static void
+check_format_cgdcont_test_ready(MMBaseModem* self,
+    GAsyncResult* res,
+    GTask* task)
+{
+    CheckFormatContext* ctx;
+    const gchar* response;
+    GList* format_list = NULL;
+    g_autofree gchar* ip_family_str = NULL;
+    g_autoptr(GError)   error = NULL;
+    gboolean            checked = FALSE;
+
+    ctx = g_task_get_task_data(task);
+
+    ip_family_str = mm_bearer_ip_family_build_string_from_mask(ctx->ip_type);
+
+    response = mm_base_modem_at_command_full_finish(self, res, &error);
+    if (!response)
+        mm_obj_dbg(self, "failed checking context definition format: %s", error->message);
+    else {
+        format_list = mm_3gpp_parse_cgdcont_test_response(response, self, &error);
+        if (error)
+            mm_obj_dbg(self, "error parsing +CGDCONT test response: %s", error->message);
+        else if (mm_3gpp_pdp_context_format_list_find_range(format_list, ctx->ip_type,
+            &ctx->min_profile_id, &ctx->max_profile_id))
+            checked = TRUE;
+    }
+
+    if (!checked) {
+        ctx->min_profile_id = 1;
+        ctx->max_profile_id = G_MAXINT - 1;
+        mm_obj_dbg(self, "unknown +CGDCONT format details for PDP type '%s', using defaults: minimum %d, maximum %d",
+            ip_family_str, ctx->min_profile_id, ctx->max_profile_id);
+    }
+    else {
+        ctx->min_profile_id = 1;   
+        ctx->max_profile_id = 1;   
+        mm_obj_dbg(self, "+CGDCONT format details for PDP type '%s': minimum %d, maximum %d", ip_family_str, ctx->min_profile_id, ctx->max_profile_id);
+    }
+
+    mm_3gpp_pdp_context_format_list_free(format_list);
+
+    g_task_return_boolean(task, TRUE);
+    g_object_unref(task);
+}
+
+
+static void
+modem_3gpp_profile_manager_check_format(MMIfaceModem3gppProfileManager* self,
+    MMBearerIpFamily                ip_type,
+    GAsyncReadyCallback             callback,
+    gpointer                        user_data)
+{
+    GTask* task;
+    CheckFormatContext* ctx;
+
+    task = g_task_new(self, NULL, callback, user_data);
+    ctx = g_slice_new0(CheckFormatContext);
+    ctx->ip_type = ip_type;
+    g_task_set_task_data(task, ctx, (GDestroyNotify)check_format_context_free);
+
+    mm_base_modem_at_command(MM_BASE_MODEM(self),
+        "+CGDCONT=?",
+        3,
+        TRUE, /* cached */
+        (GAsyncReadyCallback)check_format_cgdcont_test_ready,
+        task);
+}
+
+
diff --git a/src/plugins/fm350gl/mm-broadband-modem-fm350gl.h b/src/plugins/fm350gl/mm-broadband-modem-fm350gl.h
new file mode 100755
index 0000000..dbcf596
--- /dev/null
+++ b/src/plugins/fm350gl/mm-broadband-modem-fm350gl.h
@@ -0,0 +1,51 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) PMGZED
+ * Copyright (C) ModemManager Team
+ */
+
+#ifndef MM_BROADBAND_MODEM_FM350GL_H
+#define MM_BROADBAND_MODEM_FM350GL_H
+
+#include "mm-broadband-modem.h"
+
+#define MM_TYPE_BROADBAND_MODEM_FM350GL            (mm_broadband_modem_fm350gl_get_type ())
+#define MM_BROADBAND_MODEM_FM350GL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_BROADBAND_MODEM_FM350GL, MMBroadbandModemFM350GL))
+#define MM_BROADBAND_MODEM_FM350GL_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_BROADBAND_MODEM_FM350GL, MMBroadbandModemFM350GLClass))
+#define MM_IS_BROADBAND_MODEM_FM350GL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_BROADBAND_MODEM_FM350GL))
+#define MM_IS_BROADBAND_MODEM_FM350GL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_BROADBAND_MODEM_FM350GL))
+#define MM_BROADBAND_MODEM_FM350GL_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_BROADBAND_MODEM_FM350GL, MMBroadbandModemFM350GLClass))
+
+typedef struct _MMBroadbandModemFM350GL MMBroadbandModemFM350GL;
+typedef struct _MMBroadbandModemClass MMBroadbandModemFM350GLClass;
+typedef struct _MMBroadbandModemFM350GLPrivate MMBroadbandModemFM350GLPrivate;
+
+struct _MMBroadbandModemFM350GL {
+    MMBroadbandModem parent;
+    MMBroadbandModemFM350GLPrivate *priv;
+};
+
+struct _MMBroadbandModemFM350GLClass{
+    MMBroadbandModemClass parent;
+};
+
+GType mm_broadband_modem_fm350gl_get_type (void);
+
+MMBroadbandModemFM350GL *mm_broadband_modem_FM350GL_new (const gchar *device,
+                                                       const gchar *physdev,
+                                                       const gchar **drivers,
+                                                       const gchar *plugin,
+                                                       guint16 vendor_id,
+                                                       guint16 product_id);
+
+#endif /* MM_BROADBAND_MODEM_FM350GL_H */
diff --git a/src/plugins/fm350gl/mm-plugin-fm350gl.c b/src/plugins/fm350gl/mm-plugin-fm350gl.c
new file mode 100755
index 0000000..ae08880
--- /dev/null
+++ b/src/plugins/fm350gl/mm-plugin-fm350gl.c
@@ -0,0 +1,101 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) PMGZED
+ * Copyright (C) ModemManager Team
+ */
+
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <time.h>
+
+#include <gmodule.h>
+
+#define _LIBMM_INSIDE_MM
+#include <libmm-glib.h>
+
+#include "mm-plugin-common.h"
+#include "mm-broadband-modem.h"
+#include "mm-serial-parsers.h"
+#include "mm-log-object.h"
+#include "mm-iface-modem.h"
+
+#include "mm-broadband-modem-fm350gl.h"
+
+#define MM_TYPE_PLUGIN_FM350GL mm_plugin_fm350gl_get_type ()
+MM_DEFINE_PLUGIN (FM350GL, fm350gl, fm350gl)
+
+
+
+static MMBaseModem *
+create_modem (MMPlugin *self,
+              const gchar *uid,
+              const gchar *physdev,
+              const gchar **drivers,
+              guint16 vendor,
+              guint16 product,
+              guint16 subsystem_vendor,
+              GList *probes,
+              GError **error)
+{
+    return MM_BASE_MODEM (mm_broadband_modem_FM350GL_new (uid,
+                                                  physdev,
+                                                  drivers,
+                                                  mm_plugin_get_name (self),
+                                                  vendor,
+                                                  product));
+
+}
+
+
+
+MM_PLUGIN_NAMED_CREATOR_SCOPE MMPlugin *
+mm_plugin_create_fm350gl (void)
+{
+    static const gchar *subsystems[] = { "tty", "net", NULL };
+    static const mm_uint16_pair product_ids[] = {
+        { 0x0e8d, 0x7126 },
+        { 0x0e8d, 0x7127 }
+    };
+
+    return MM_PLUGIN (
+        g_object_new (MM_TYPE_PLUGIN_FM350GL,
+                      MM_PLUGIN_NAME,               MM_MODULE_NAME,
+                      MM_PLUGIN_ALLOWED_SUBSYSTEMS, subsystems,
+		              MM_PLUGIN_ALLOWED_PRODUCT_IDS, product_ids,
+                      MM_PLUGIN_ALLOWED_AT,         TRUE,
+		              MM_PLUGIN_ICERA_PROBE,         FALSE,
+                      MM_PLUGIN_REMOVE_ECHO,         TRUE,
+                      NULL));
+}
+
+static void
+mm_plugin_fm350gl_init (MMPluginfm350gl *self)
+{
+}
+
+
+
+static void
+mm_plugin_fm350gl_class_init (MMPluginfm350glClass *klass)
+{
+    MMPluginClass *plugin_class = MM_PLUGIN_CLASS (klass);
+    plugin_class->create_modem = create_modem;
+}
+
+
diff --git a/src/plugins/meson.build b/src/plugins/meson.build
index 3742ced..840f43e 100644
--- a/src/plugins/meson.build
+++ b/src/plugins/meson.build
@@ -775,6 +775,24 @@ if plugins_options['option']
   }}
 endif
 
+
+# plugin: option fm350gl
+if plugins_options['fm350gl']
+  sources = files(
+    'fm350gl/mm-plugin-fm350gl.c',
+    'fm350gl/mm-broadband-bearer-fm350gl.c',
+    'fm350gl/mm-broadband-modem-fm350gl.c',
+  )
+
+  plugins += {'plugin-fm350gl': {
+    'plugin': true,
+    'module': {'sources': sources, 'include_directories': plugins_incs, 'c_args': '-DMM_MODULE_NAME="fm350gl"'},
+  }}
+plugins_udev_rules += files('fm350gl/77-mm-fm350gl.rules')
+endif
+
+
+
 # plugin: option hso
 if plugins_options['option-hso']
   sources = files(
diff --git a/src/plugins/mm-builtin-plugins.c b/src/plugins/mm-builtin-plugins.c
index 0fd9670..f9a0466 100644
--- a/src/plugins/mm-builtin-plugins.c
+++ b/src/plugins/mm-builtin-plugins.c
@@ -112,6 +112,9 @@ MMPlugin *mm_plugin_create_samsung (void);
 #if defined ENABLE_PLUGIN_SIERRA
 MMPlugin *mm_plugin_create_sierra (void);
 #endif
+#if defined ENABLE_PLUGIN_FM350GL
+MMPlugin *mm_plugin_create_fm350gl (void);
+#endif
 #if defined ENABLE_PLUGIN_SIERRA_LEGACY
 MMPlugin *mm_plugin_create_sierra_legacy (void);
 #endif
@@ -247,6 +250,9 @@ mm_builtin_plugins_load (void)
 #if defined ENABLE_PLUGIN_SIERRA
     PREPEND_PLUGIN (sierra);
 #endif
+#if defined ENABLE_PLUGIN_FM350GL
+    PREPEND_PLUGIN (fm350gl);
+#endif
 #if defined ENABLE_PLUGIN_SIERRA_LEGACY
     PREPEND_PLUGIN (sierra_legacy);
 #endif
